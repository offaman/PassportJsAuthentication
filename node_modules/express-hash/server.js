const elliptic = require('elliptic');
const querystring = require('querystring');
const crypto = require('crypto');
const defaults = require('./defaults.json');

const verify = (options = defaults) => (req, res, next) => {
  try {
    const EdDSA = elliptic.eddsa;
    const ec = new EdDSA('ed25519');
    let message = {};
    if (!options.hashKey || typeof options.hashKey !== "string") {
      throw new Error("Please provide a valid hash key");

    }
    if (options.checkTime) {
      if (!options.limit || Number.isInteger(options.limit) || !options.limit > 0) {
        throw new Error("Please provide a valid time limit");
      }
      if (req.method === 'GET' && !req.query.time) {
        throw new Error("Missing query param time in request");
      }
      if (req.method !== 'GET' && !req.body.time) {
        throw new Error("Missing  time in request body");
      }
      const timeCreated = req.method !== 'GET' ? req.body.time : req.query.time;
      const timeDiff = (new Date().getTime() - timeCreated) / 1000;
      if (timeDiff > options.limit) {
        throw new Error("Request took too long to reach");

      }
    }
    message.body = req.body || {};
    message.query = req.query || {};

    const shaMsg = crypto.createHash(options.algorithm).update(JSON.stringify(message)).digest("hex");
    const keyPvt = ec.keyFromSecret(options.hashKey);
    const result = ec.verify(shaMsg, req.headers.signature, keyPvt.getPublic());

    delete req.headers.signature;
    if (req.body.time) {
      delete req.body.time
    }
    if (req.query.time) {
      delete message.query.time;
      const sq = req.originalUrl.split('?');
      if (Object.keys(message.query).length === 0) {
        req.originalUrl = sq[0];
      } else {
        const qParams = querystring.stringify(message.query);
        req.originalUrl = `${sq[0]}?${qParams}`;
      }
    }
    if (!result) {
      throw new Error("Request is tampered");

    }
    next();
  } catch (err) {
    console.error('error ', err);
    throw new Error("Failed to verify the hash");

  }
};

module.exports = { verify }